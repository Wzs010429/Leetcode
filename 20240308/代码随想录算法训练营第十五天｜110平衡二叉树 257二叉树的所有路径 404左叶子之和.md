# 代码随想录算法训练营第十五天｜110.平衡二叉树 257.二叉树的所有路径 404.左叶子之和

## 110.平衡二叉树

首先在这里写一下平衡二叉树的定义 就是左子树和右子树的高度差不能超过1

所以我们可以从递归和迭代两个角度去考虑这个问题

高度的定义是从叶子节点开始计算的 所以一个节点的左右子树结构不同的情况下的  计算出来的树节点高度可能是不一样的

### 递归

递归我们需要明确三个步骤：

1. 明确递归函数的参数和返回值
2. 明确终止条件
3. 明确单层递归的逻辑

首先 递归函数我们要传入的参数是 一个节点的根节点 返回的值应该是这个根节点的计算中的高度

但是我们还需要一个标记，这个标记是用来帮助我们判读这个二叉树是不是已经不是一个平衡二叉树了

比如我们用-1来表示一个二叉树已经不是一个平衡二叉树了，因为二叉树的节点的高度不可能是一个负数 所以这个flag是OK的


对于这个递归的终止条件就是我们检索了空节点，那么我们应该返回高度0

对于单层递归逻辑：

1. 如果我们检索到了空节点 就是0
2. 如果我们检索到了左右子树的高度差大于了1，那么我们返回-1
3. 如果我们已经知晓了左子树或者右子树已经不是一个平衡二叉树了 我们返回-1
3. 如果左右子树的高度是满足条件的，那么我们会取左右子树高度更大的那一个+1来代表当前节点的高度

### 迭代


迭代的话首先我们明确了 这个题目要求我们DFS深度优先 因为我们得先求子树的高度，然后一点点往回传

这种情况下使用栈对我们来说是更好的选择

但是与传统的栈不同，我们需要有具体的回溯操作，因为我们深入到叶子结点之后，我们还需要回退计算他们父节点的高度

这里有一个很巧妙的做法，就是如果我们判断出来当前节点不是叶子结点的时候，我们就在向栈中添加他们的左右节点的时候，先添加一个None空节点，这样我们就可以重新对父节点进行操作

剩下的逻辑思路和递归的思路是完全一致的 从下到上确定每一个节点的高度 然后进行比较 只要出现一个非平衡二叉树 我们就可以直接返回False 不需要递归到最后了

## 257.二叉树的所有路径



## 404.左叶子之和


