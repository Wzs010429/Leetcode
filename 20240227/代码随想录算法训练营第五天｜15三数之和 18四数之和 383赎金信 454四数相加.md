# 代码随想录算法训练营第五天｜15.三数之和 18.四数之和 383.赎金信 454.四数相加

今天的题很明显给我上了一个大段位的强度，一时间没缓过来，几乎每一道题目都需要看一看解析然后自己合计合计才能做出来

## 15.三数之和

这道题我堪称今天憋死我的题目 最开始死活没想明白

不纠结了 我直接开始用双指针去做这道题目

首先它没要求我们去返回每一个结果值的坐标，这意味着我们可以对数组进行排序，实际上我们要是想要用双指针，我们必须要进行排序

最外层的for循环一定是从头递归到结尾的，我们将其中一个值固定下来，然后用左右双指针来控制剩下两个值

left的起始坐标是i+1 right的坐标是len(nums)-1 这个不难理解，就是从数组的左右端点开始进行遍历

因为我们已经将nums排好序了 而且三个数的和应该是等于0 所以如果目前这三个和大于零 那就说明整数的值太大了，那就需要我们把右指针往左挪，同理，如果总和小于0，我们把左指针往右挪，循环坐标i是固定的，不能进行修改

有几种情况我们可以在移动指针之前就排除出来，如果说i坐标对应的值就已经大于0了，那么不用玩了，一个非递减顺序排列的数组第一个数就大于0，那么三个数加和一定大于0 所以肯定不存在结果

此外 我们还需要进行去重，这里我们是主要判断

```{python}
if i > 0 and nums[i] == nums[i - 1]:
    continue
```

这里主要是判断i坐标下有没有重复的值，我们需要去重，但是我们要去的就是两个三元组不能是完全一致的，所以对于这个循环遍历的i坐标的值，如果前后两个值出现一样的，然后后面两个左右指针找到的值也是一样的，那么一定会出现相同的两个三元组，所以我们要避免这种情况

那么如果我们找到了一个三元组，这个时候除了把这个值存起来，我们也需要保证这个值后续不会存在重复值，所以我们对左右指针指向的值也进行一个筛选，两个指针都往中间移动，来找有没有和他们移动指针前相同的值，有的话我们得去掉，避免重复



## 18.四数之和

这道题目就不重新赘述了，基本思路和15题三数之和的原理是完全一样的，但是因为多了一个数，所以时间复杂度也多了一层变成了n的立方

主要思路还是 我们固定两个数 这两个数的确定就是两个for循环 然后我们用左右双指针来控制剩下的两个值的移动

但是多了几个判定条件，首先就是四个值的和是target 这个target不一定是0 可能是负数或者正数

如果是整数 那么我们前面的i坐标对应的值如果直接大于target了，那么不用计算了，第一个值都大于target了那后面只能更大

但是如果说target是一个负数，我的i坐标起始的数据也是负数，那么负数相加是越来越小的，这种情况下我们刚才说的i坐标数就大于target直接跳过本轮循环这个数学证明是不成立的

所以我们只需要在这种判断后面and一个target>0的条件就可以了

其他的地方和三数和没有区别，双指针全都秒了


## 383.赎金信

这道题目是今天的几道题目中相对简单的一道题目了 让我们判断一个单词是否能用另一个单词的字母构建出来

首先我们统计出来这两个单词的哈希表，格式应该是{字母：出现次数}

然后我们只要保证被构成的单词里面的每一个字母都在用来构成的单词中出现了，并且字母的个数都要更大就可以了

这道题直接秒 没什么难度


## 454.四数相加

最开始还以为四个数了，这道题目还能有什么高深的解法呢，结果官方的时间复杂度也是n方，那我放心了

首先我们将四个数组分成AB CD两组

然后我们把AB加和 CD加和 把所有出现的可能的结果都存在哈希表中

这样我们能获得两个哈希表 数据格式应该是{两个数组元素加和的值：出现的次数}

然后我们遍历AB哈希表的所有键，如果0-CD出现在了CD的哈希表中，那说明他们可以组合然后得到0，出现的次数应该是这两组值各自出现的次数相乘

举个例子 在AB哈希表中 结果为1的次数出现了5次，在CD哈希表中，结果为-1的次数出现了2次，那么一共就有出现10次 四个数加和等于0的情况出现

我们把所有的这种情况全部统计出来，就得到了最终的结果

> 一个补充：ansAB[tmp] = ansAB.get(tmp, 0) + 1 这种更新哈希表的表达得学会，对于已经存在的值直接自增1，对于不存在的值要赋值为1

