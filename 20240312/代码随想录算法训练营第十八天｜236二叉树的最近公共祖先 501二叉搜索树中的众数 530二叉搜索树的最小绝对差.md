# 代码随想录算法训练营第十八天｜236.二叉树的最近公共祖先 501.二叉搜索树中的众数 530.二叉搜索树的最小绝对差



## 236.二叉树的最近公共祖先

这道题我认为解题思路是一个超级巧的方法

首先我们明确一件事情 就是什么状态下我们能够判断出来当前节点是二叉树的最近公共祖先

我们认为节点的存在应该有两种情况：

1. 第一种就是两个节点应该在完全分离的两个不同的分支上
2. 第二种是其中一个节点q应该在另一个节点p的某一个分支下面


虽然是两种节点可能存在的情况 但是实际上我们递归用一套思路就能解决


我们的方案应该是这样的 首先我们肯定要从底开始 然后如果我们遍历到了q或者p节点，我们就把这个节点往上返回就好了 注意我们返回的是当前的节点

然后我们开始往上返回 如果我们返回到了某个中间阶段的节点 然后这个节点的左树和右树都是有值的 不是空的 就说明这个节点就是我们想要的最近的公共祖先

相当于是只要我们在一个分支检索到了p或者q 我们就把这个节点往上传 告诉上面我们找到了这个节点

> 对于我们刚才提到的第二种情况 如果两个节点在一个分支上呢？

其实这个不用担心，因为一旦我们检索到了其中的一个值，我们就会返回当前的节点，也就是说如果q在p的下面，我们会先检索到p 然后就直接返回了p

这个时候如果我们往上传 会因为一直没找到q而继续一直往上传 知道我们传到了根节点root

因为两个节点p和q是一定存在的 所以这个时候我们就能确定他俩在一个分支上了 而且我们往上传递的就是那个靠上面的节点值p 也就是他俩的公共祖先



## 501.二叉搜索树中的众数

递归法就是遍历每一个元素节点 然后用一个哈希表来统计值就可以了 找到累计数量最多的元素 如果是一个就返回一个值 否则就是全部返回


### 迭代法 但是利用了二叉搜索树的特性

这里的迭代法其实挺巧妙的 我想着重写一下

我们希望我们在遍历这个二叉搜索树的时候就是按照一个有序的从小到大的数组顺序进行遍历的 在这里我们采用了快慢双指针的方式来进行遍历

其实更准确的叫法应该是先谭指针和溯源指针 我觉得这么更贴切hhh

前面的指针用来对子节点进行探寻，先往下走，后面指针则是用来进行溯源，因为走完左子树我们还需要回到右子树

然后我们统计众数的思路其实是 因为我们获得的数组其实是连续的，所以我们可能在一段时间之内获得的都是同一个数据，我们可以统计出来个数，如果说这个新的数据的个数超过了我们的历史记录

（历史记录应该是有一个数据来负责进行存储的）如果超过了 我们就把之前存在最后结果列表中的元素全部清空，重新进行更新，因为我们找到了更多的嘛

这样记录只要被刷新了一次 我们就要重新计算需要被放在结果列表里面的元素

#### 指针移动方法

这个指针移动也是有说法的

首先我们就是想要中序遍历嘛 所以我们希望找到在最左边的节点，我们就一直append left节点 直到最深层 然后开始pop

注意到此时此刻为止我们都还没开始使用溯源节点

如果溯源节点是空的 我们需要把count（这就是我们针对某一个数据的计数器，他不是历史记录的计数器，那个还有另一个）重新赋值为1 这说明我们刚开始进行数据统计

如果溯源节点已经存在了并且他的值和我们快指针对应的节点是相同的，就说明我们找到了相同的数据 这个时候给count累加就好了

如果不相等 就说明是一个新的值了 就需要重新进行计数 并且就需要判断一下我们这个已经统计好的数据是不是一个新的记录 如果是就需要进行更新

然后是节点的更替 把快指针的节点给回溯指针 然后快指针去看当前节点对应的右节点 这就是一个标准的左中右 中序遍历

至于中间的向栈中添加和pop元素的逻辑，我们再捋一下：首先我们不断的left节点添加 并且把当前节点的左节点赋值给当前节点

所以到头的时候（也就是我们找到了叶子节点） 快指针的位置其实是在叶子结点的left上 这是一个不存在的值

然后我们条件判断出来了 我们pop一个 此时我们把叶子节点pop出来了 然后进行操作 然后我们把pre（回溯节点）赋值了cur（快节点）

然后cur去找了他的right 也就是叶子节点的right 这也是一个None值

所以我们下一轮循环还是继续pop 此时就是最开始叶子节点的父节点了 也就是我们真正溯源了 这个值理论上应该是和那个叶子节点相等或者比他大的（这个搜索二叉树允许了数据相等）

然后我们把pre给这个节点 cur去探这个节点的right 就去看右边的结果了

所以这就是一个完整的中序遍历的流程




## 530.二叉搜索树的最小绝对差

这道题目其实不需要再解释了

只要我们把它转化成一个有序的从小到大的数组 我们就可以做了


只需要两两比较数据的大小就可以了 别忘记添加一个绝对值

