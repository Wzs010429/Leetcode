# 代码随想录算法训练营第二十六天｜37.解数独 51.N皇后 332.重新安排行程

今天的题目对我来说我感觉是比较难的题目了 然后我争取把每一道题目都写一下我的想法

## 37.解数独

这道题是今天三道题目里面我认为最难的一个，也是最值得思考的一个题目

首先还是判定函数，判定在这个行 这个列，这个对应的格子内部没有和自己重复的数据（注意数据的格式是str字符串）

这个还是蛮简单的，我们需要传入的参数就是，这个表格的信息，横纵坐标，一个想要填写的值

然后这个backTracking函数肯定也是需要有判定条件的，是一个有参数返回的回溯算法

我们不可避免地会用双循环遍历每一个位置的信息，如果我们遇到了数字就直接跳过，如果没遇到数字，那么我们需要将1到9都填写进去看看是不是有效的

所以这是一个三层循环，两层为了遍历表格，一层为了遍历数字

当我们把一个数字填写进去然后开始进入递归的时候，注意我们传进去的还是这个表格的信息，而不需要对递归做任何修改，因为我们填写了一个新数字，我们还是得从头开始递归，从第一个位置开始查填写下一个数字在哪个位置

如果说1到9都不满足条件，也就是下一轮直接判断条件没进去，那么我们需要return False，因为这个backTracking函数是带参数的，需要返回一个bool值

到循环的最后的最后，如果这个表格没有死在半路，我们是需要返回一个True表明这个表格已经完成了 也就是说这个数独题目已经做好了

## 51.N皇后

首先这道题目我们需要写出来一个函数来判定当前位置，如果我想要放一个皇后 那么这个位置是不是一个合法的位置

这个判定函数给定的参数应该有，棋盘的信息，横纵坐标

我们需要判定一行，一列，两个对角线上都没有皇后，但是实际上我们只需要判断他们前面有没有皇后就可以了，对于行，我们只要从0递增到对应的row的值就可以了，但是列是从0到n都要进行遍历的

我们写好了这个函数以后，开始构建我们的backTracking函数

这个函数的终止条件一定是我们遍历到最后一行，把所有能放皇后的位置都放上了，所以row==n的时候就是结束的之后，因为最大的行坐标是n-1，但是因为我们是递归，所以+1

然后for循环也是对每一列进行循环，不用对行，因为我们每一轮都会对row这个值+1 我们需要在循环外部判定这个值达没达到终止条件的，所以不能写在循环里面

循环里面就是，先判断这个地方放皇后是不是合法的，如果是，我们给这个位置放一个皇后

字符串的修改不能直接按照索引进行修改，所以我们还是需要用切片，把这个位置添加进来一个皇后

然后进入下一层，我们就递归就行 但是递归函数之后别忘了把我们递归之前修改的信息回溯回来，其实也就是一个字符串的值的修改的信息



## 332.重新安排行程

这道题很奇怪 卡哥给的回溯算法现在是完全不过了最后一个测试案例

但是这道题目的回溯算法还是比较有意思的 值得我们去详细研究


首先就是因为我们要保证每张机票只被用过一次 所以used数组是一定要被使用的

所以backTracking函数中的for循环就是所有机票的循环（用len计算长度）

这里我们还需要一个计数工具，来帮我们暂时记录在path中存储的机场的数量。按照题目要求，如果这个路线中要包含到所有的机票的起降，那么我们写在path里面的机场的数量应该是机票的数量+1（因为要包含起降）

所以退出条件我们就确定好了，机场数量如果等于机票数量+1

循环条件其实就是我们获取了一张机票（机票要先排序，因为题目要求了从排序小的开始找），然后把这张机票标记为被使用过了，然后讲机票中的降落点更新为起飞点，去进行遍历递归

但是这道题目为什么最后还让我们加了一个判定状态呢？也就是说之前我们做的回溯的题目绝大部分都是没有返回值的（也就是backTracking函数不需要返回值）但是这道题需要

这是因为题目要求我们只返回一个解，所以只要判定这个解生效了，我们就终止这个递归和回溯的过程

然后就是需要注意的，只有一个结果返回，但是我们还是append到了result里面，所以我们最后return的应该是result数组中的第一个元素