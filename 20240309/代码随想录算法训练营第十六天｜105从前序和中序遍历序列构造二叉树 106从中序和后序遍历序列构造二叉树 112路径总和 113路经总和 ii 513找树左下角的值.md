# 代码随想录算法训练营第十六天｜105.从前序和中序遍历序列构造二叉树 106.从中序和后序遍历序列构造二叉树 112.路径总和 113.路经总和 ii 513.找树左下角的值

## 105.从前序和中序遍历序列构造二叉树

前序：中左右

中序：左中右

所以我们可以先拿出来前序的第一位 这个肯定是根节点

然后我们用根节点去分割中序中的左子树和右子树

然后我们统计出来左子树和右子树的长度 再去分割前序的左子树和右子树

然后我们就分别获得了左右子树的前序和中序 然后递归就好了



## 106.从中序和后序遍历序列构造二叉树

后序：左右中

中序：左中右

所以我们可以先拿出来中序的最后一位 这个肯定是根节点

然后我们用根节点去分割中序中的左子树和右子树

然后我们统计出来左子树和右子树的长度 再去分割后序的左子树和右子树

然后我们就分别获得了左右子树的后序和中序 然后递归就好了



## 112.路径总和

### 迭代


迭代很简单 就是我们只要写出来达到当前节点已经累加的值就可以了 迭代方式什么的其实都无所谓

然后判断当前节点是不是叶子节点 并且累加的值是不是target 如果是直接True 否则False


### 递归

递归我们可以在递归考虑左子节点和右子节点的时候 把target的值减去节点本身的值然后递归传递下去就可以了

需要传递的参数只有 当前节点值 当前目标值

判断终止条件只有 当前节点是叶子结点 target是0

## 113.路经总和 ii

和路径总和的原始题目很像 包括解法都很像


### 迭代

迭代就是我们的数据结构的存数据的格式发生了一点变化，除了节点本身的值我们还要存一下路径，所以一个组合的元组数据结构就可以了


### 递归

递归就是多了两个参数 一个是最后的结果列表result 一个就是当前的path

path就是从根节点遍历到当前节点的路径数组 如果当前节点判断出来是一个叶子结点并且target的值为0 那么这个path就是我们想要的path 把它append到结果列表里面就可以了



## 513.找树左下角的值


### 迭代

只要我们层序遍历迭代就可以了 但是我们要注意的是我们的迭代顺序是中右左，把左子树的迭代顺序放在最后，因为我们要找的是左下角的值


### 递归

前序遍历就可以了 中左右

我们传入的参数应该是节点和深度两个参数

有一个全局的参数来帮助我们找到最深层的节点，如果当前节点的深度大于历史最大深度，那么我们就需要对这个全局参数进行更新

当我们找到叶子结点之后，我们直接判断他的深度 深度更新了的话 我们直接返回这个值

这里我们会有一个疑问 因为我们要找左下角的值，我们没对左节点和右节点进行特殊的区别处理，直接看叶子节点就返回了，玩意返回给我们一个右叶子节点的？

其实答案是不会的 因为我们始终遵循的是前序遍历，哪怕我们找到了叶子节点那一层，我么也是最先遍历的最左侧的节点，一旦确定了是叶子节点我们就直接返回了，所以我们找到的一定是最左下角的叶子节点

