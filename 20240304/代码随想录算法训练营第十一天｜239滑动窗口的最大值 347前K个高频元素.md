# 代码随想录算法训练营第十一天｜239.滑动窗口的最大值 347.前K个高频元素


今天的这两道题目其实蛮有意思的 也有很多需要我们进行总结的思路和方法，尤其是还有一些python的库我之前没有接触过

## 239.滑动窗口的最大值

这道题目刚拿到手的时候我思考的是暴力破解的方式，对于每一个窗口，我们都通过一种快速排序的方式计算出来当前的窗口（子串）内部的最大元素并且返回出来

但是实际上我们应该有这样的一个直觉，我只需要维护当前窗口内的最大值就好了，可能下一个滑动窗口，当前窗口的最大值被保留或者被替换，都是只和这一个值有关系

这里我们考虑使用单项队列，这个单项队列的实际含义就是：我的队列开头存储的永远是在当前滑动窗口内的最大值，其余小的值会被我替换掉（其实是直接删除了）

这个单项队列需要我们自行去定义，我们在这里定义了三个函数（pop，push，maxVal）也就是移除队列，压入队列，提取最大值

### 提取最大值

这个最简单，因为上面我们说了，我们这个队列的最大值我们会放在队列的头部，所以直接return出来就可以了

### 压入队列

在将一个新的值压入队列的过程中，因为我们要保证这个值的大小，大的值要在前面，所以我们会从队列尾部开始，把所有的比我们要插入队列的这个值小的值全部pop出去，然后我们才能把要插入的这个值放进来

### 移除队列

这里我们需要移除队列的第一个元素，所以我们肯定会用到deque中的popleft()这个函数

但是我们移走元素也是有前提的：首先就是队列不能为空，再一个就是队列头部的值不能等于当前对应指针下的值

这个可能听起来比较奇怪，这里我们举一个例子：

假设k的值是3 也就是我们这个滑动窗口的大小是3，那么最开始我们会拿到数组nums中的前三位填充到这个窗口中，并且找到最大值，在这个过程中三个值都会被填入我们的单项队列

同样地，在这个过程中，可能会有一些值因为不满足大小关系被pop掉了，这个时候我们会从nums[0]开始进行pop操作，如果说pop操作的值并不是队列顶部的值。

这句话的实际意思就是，我们在nums中也可以理解为有一个指针，这个指针每次往右移动一格，就代表着有这样的一个滑动窗口在移动。所以每一次我们需要将不在这个窗口范围内的值进行删减

但是在窗口内部，也就是队列中间我们会要求这种大小关系的排列，有一些数据已经被删掉了，只留了最大的值在队列的头部，这种情况下，我们就需要判断这个队列头部的值和我们在nums中需要被pop掉的元素的值是不是一样的

如果是一样的 我们就需要删除掉 如果不是一样的 就说明这个值可能一直就不算很大，在这个队列中就排不上号 我们就不用考虑pop的问题和压力



综上，只要我们构建出来了单项队列，我们在进行nums数组迭代的过程中，对于 每一步我们都可以找到当前步骤对应的最大值并且保留下来存储在res数组中

## 347.前K个高频元素

这里我用了两种方法，一种是哈希，另一种是小顶堆



### 哈希

其实哈希是最简单的，对每一个值进行频率计算，存储在一个字典中。

然后我们就对字典进行sort 关键字是key的value，然后我们输出前k个最大value对应的key就好了



### 小顶堆

小顶堆就是说我们要维护一个二叉树，并且每次都要pop出对顶的最小的元素

当然这里面元素的大小是按照key的value去排序的

> 题外话：一个知识点补充，两个元组之间也可以进行比较的，如果说两个元组的第一个元素相同，那么开始比较第二个元素，以此类推


所以我们还是首先计算出来每一个元素的频率

然后我们还是构建这个小顶堆，这里我们用到了heapq

小顶堆的大小大于k了之后，我们就需要pop元素，当然因为heapq构建的自动就是小顶堆，所以我们直接pop堆顶元素就好了

然后最后我们把小顶堆中剩余的k个元素的key输出出来，并且要反序就好了，因为小顶堆是小在前大在后

这里的反序也有一个坑：

- a.reverse() 直接写就可以 不用重新赋值a=xxx
- reversed(a) 返回的是一个（迭代对象），所以我们还需要强转成list类型的元素

### 关于heapq

这里我们只用到了heapq.heappush 和 heapq.heappop 用于构建小顶堆和pop顶

这里面的数据结构用的还是数组的形式