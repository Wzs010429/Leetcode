# 代码随想录算法训练营第四天｜19.删除列表的倒数第N个节点 24.两两交换链表中的节点 面试题02.07.链表相交 142.环形列表 II

今天的题目说实话感觉有很多数学在里面，在做算法的时候可能一时间想不出来这么多乱七八糟的东西

## 24.两两交换链表中的节点 

这道题也挺有意思，一共有两种方法，第一种就是单指针，第二种我们可以考虑递归的方法。


### 单指针


我们需要一个临时变量tmp来存储前后两个节点中靠后的一个节点，举个例子：

目前的连接状态是： 0 A B C，其中0是dummyHead，C是下一组需要互换位置的节点，我们暂时不考虑，我们只需要把A连到C上面就可以

所以我们需要先把A记录下来，因为如果我们连接了0和B，A就会丢了，所以具体的顺序如下：

1. A用临时变量保存起来
2. 0链接到0.next.next 也就是找到B的位置
3. A链接到C 也就是0.next.next.next 因为我们还没动链表中的位置信息
4. 最后B连接A 完成0BAC的互换 然后我们把指针挪到 A的位置，然后迭代到下一轮互换

### 递归法

递归发就是当前轮次完成当前轮次的互换，然后剩下的就靠继续函数复用就好了

那样就是三个节点之间的更换 例如我们举例ABC 我需要变成BAC

如果最开始指针在head了 那么完成如下步骤：

1. newHead = head.next 新的头节点是B
2. head.next = function(head.next.next) A连接到C 函数复用，但是起点就应该是C了，后面怎么换那是递归的事情，我们不需要管
3. newHead.next = head B连接到A



## 19.删除列表的倒数第N个节点 

这道题目有两个思路：第一个依旧是双指针，第二个我们可以用栈先进后出的思想去做，最开始没想到栈，因为还以为链表这种数据结构没办法存到栈中，但是实际上能做

### 双指针

首先快指针先跑，跑出来距离差，例如倒数第2个节点，那么快指针就得先跑1格，这样我们可以保证快指针到结尾的时候，慢指针正好到了需要删除的那个节点

但是实际上我们需要到被删除节点的前一个节点来进行删除操作，所以倒数第N个节点，那么快指针就先跑N个格子

但是还有一个问题，quick指针本身是会跑到null的，因为我们的判断条件是while quick is not None，所以这里面微调一下，那就是再多跑一个格子，就是N+1

接下来就是确定了慢指针的位置，然后做链表删除节点就好了

### 栈思想

节点是可以存的 所以先跑一轮 把所有的节点存起来 然后pop()往外退节点，记得多退一个因为我们需要找到被删除的节点的前一个节点

### 笨蛋方法

先把一共有多少个节点计算出来，然后算出来被删除节点前面的那个节点在链表中的具体位置（就是需要next多少次），然后执行节点删除的操作


## 面试题02.07.链表相交 

这道题目有一个很刁钻的做法，我们这里就不考虑了，那纯是数学问题，感觉面试要是做根本想不出来这么巧的方法。

### 双指针方法

还是比较喜欢使用双指针来解决一些通用的问题，比较爽

首先我们用两个指针来遍历出来AB两条路线的长度，然后对于比较长的那一条路，我们让他的指针提前走，让两个指针在开始的时候到终点的距离是一致的

这样两个指针在移动的时候，每次都是移动一个格子，就能判断出来有没有交点

### 很巧的数学方法

有一个很巧的数学方法，真的很巧

我们写一些数学假设，假设两条链有重合，他们各自不重合的部分长度分别是a和b，重合部分的长度是c

我还是设置两个指针去迭代跑，指针A把A链跑完了，我让他去跑B，同理B跑完了去跑A

这样的情况下，每一个指针在跑一个a+b+c+2之后，必定会重合到一块去

也就是说把自己的链跑完了，再跑另一方的不重合的链，至于这个+2，一个是为了判断当前链跑完之后必须存在的一个None，另一个则是判断进入重合状态的第二个c的第一个节点


## 142.环形列表 II


这道题感觉数学的成分更多，自己想肯定是完全想不出来这个做法。

### 方法一 集合法

python创建一个set，然后从头节点head开始递进，每遍历到一个新的节点，就把它加入到set中，在每次遍历之前会先判断set里面有没有这个节点。

如果已经存在这个节点了的话，那就说明构成了一个环，这种情况下重复的这个节点就是我们想要找的节点。


### 方法二 双指针法

这个方法涉及到了数学逻辑的推理，我还是在这里写一遍，方便我去回顾复习。。

我们首先假设这个链表是存在环的，快指针和慢指针一定会在环的内部相遇碰撞，这里我们定义三个变量：

- x：表示整个链表中不成环的链表区间的长度
- y：以环起点为开始到两个指针碰撞的环内位置的距离长度
- z：环内除去两指针碰撞的剩余长度


我们假定慢指针每次往前推进1个进度，快指针推进2个进度。这样在t个时间之内（这个t是实际上没有意义，我们本质看的是路经计算）快指针的路程应该是慢指针路程的两倍。

有几个数学证明的前提，其实很容易理解，我就当结论写在这里就不做数学证明了：

1. 慢指针进入环之后一定还没有走完第一圈就会和快指针相遇
2. 快指针一定是在环内走了几圈之后去追慢指针

列一下距离的数学等式，慢指针行走距离2倍等于快指针

$$ 2*(x+y) = x+y+n*(y+z)$$

$$ x = (n-1)*(y+z)+z$$


其中n代表的是快指针为了等慢指针在环内跑的圈数，这个n一定大于等于1。这个推理出来的x的结论也就是说如果快指针在环内一圈都没有跑完的情况下（所谓的极端情况），这个时候x只和z有关。

这样我们就能得出结论：当两个指针碰撞的时候，我记录下来这两个指针在环内的位置，然后我在head放一个新的指针，新指针和老指针一起往前迭代，每次迭代1格，他俩碰撞的那一刻就是我们想要求的环的交点位置。

这完完全全是通过数学做出来的，不推理一下还真不会，搞清楚这个数学逻辑这道题目就好写了。
