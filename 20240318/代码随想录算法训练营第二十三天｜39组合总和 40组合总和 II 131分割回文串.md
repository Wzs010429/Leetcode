# 代码随想录算法训练营第二十三天｜39.组合总和 40.组合总和 II 131.分割回文串


**重点中的重点**：append path的时候一定要path[:]否则是直接引用地址，而不是把值传进去

## 39.组合总和

这道题的重点是注意题目要求了我们可以使用重复的元素，也就是说从本轮backTracking迭代进入下一轮的时候，迭代元素i我们直接送进去，不能i+1

终止条件应该是等于target就存结果 如果大于了就直接return

## 40.组合总和 II

每个数字只能使用一次，我们的第一反应就是前后比较，这就需要首先我们对这个nums数组进行排序，这样我们保证了数组有序才能够进行前后元素的比较

剩下的思路和39题没有区别，终止条件还是那两个：如果等于target就存入结果 如果大于了就直接return

在大的for循环之后，我们要首先判断前后两个元素是不是一样的，也就是这个元素是否被使用过 这个能判断的前提是i已经大于startIndex了，否则就开头一个元素我们没办法比较前后两个值



## 131.分割回文串

这道题目我是真正觉得稍微有一点难度的题目

首先就是得写一个回文数的判定的函数，要求必须要有左指针和右指针，因为这方便我们对原始数组进行操控，给原数组切片不太合适

然后这道题目的逻辑其实是：外层的for循环就是给我整个数组的第一部分切片，我的指针遍历到哪儿，前面的那个部分是不是回文数

如果前面的部分已经是一个回文数了，那么好我接下来开始对剩下的数组部分进行递归切片，再去看下一个切片的节点在哪里

以此类推，通过这样我们可以把所有的字符串切出来，并且保证每一个部分都是一个回文数

我们向path中添加的是这个path.append(s[startIndex:i + 1])

这也就是我们说的外层大的for循环做的事情就是判断我这个for循环的指针走到哪了，前面的部分是不是一个回文数，如果是一个回文数，那么直接把这个部分添加到path中作为一个排列中的一个部分

