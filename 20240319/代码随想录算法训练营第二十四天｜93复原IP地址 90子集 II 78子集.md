# 代码随想录算法训练营第二十四天｜93.复原IP地址 90.子集 II 78.子集



## 93.复原IP地址

这道题我认为是今天最难的一个题目


backTracking函数中除了常用的那些（包括了startIndex）之外，我们引入了一个新的参数part 初始值为1 因为最开始就是一整个字符串所以就是1段

因为ip地址只有四段，所以我们可以统计出来当前的分割情况来帮助我们判断我们到底需不需要return


首先就是我们要写出来一个满足条件的ip段码：要求也很简单： isValidNum
1. 开头不能是0
2. 不能大于255
3. 题目说了都是数字所以其他异常情况我们可以不用写

### 终止条件

如果说part已经变成了4 就说明其实我们已经分割好了四段 这个时候我们判断最后一段是不是有效的ip段码，如果是，直接加一个英文"."然后加进来就可以了

然后我们直接append到result里面就可以了 作为一个有效的输出

如果虽然满足了4段但是最后一段其实不满足ip段码的条件那么我们直接return


### backTracking函数

这道题目的path路径添加其实被写在了for循环内部

和之前那道回文数的题目完全一致，最外层的for循环其实是为了从最开始指针遍历，一点点找到一个满足ip段码要求的上限，比如说第一轮1这个值ok，第二轮12这个值也是ok的，第三轮128ok，第四轮就肯定不行了

在这个每一个大的for循环OK的情况下，我们进行内部的迭代

所以再往下传的时候，我就需要在path中保存历史值，所以我们传给下一轮的就是历史值path+"."+当前轮满足条件的值（切片）

而且因为我们是先判定这个遍历的值满不满足条件，然后往下传，我们没去更新path的值，而是把一个组合值直接传下去

所以我们回溯也不需要pop 说白了就是我们也没append 这个path


## 90.子集 II

相比于70题 这个题目有一点小小的改进 但是也蛮简单的

如果要求了不重复 那就说明我们首先要对这个数组进行sort()排序了

然后在for循环内部，我们首先要判断当前这个位置的元素和上一个位置的元素是不是一样的，如果是一样的我们直接continue这一轮for循环

判断一样首先就要求我们的i一定要大于startIndex即可 没有其他的要求


## 78.子集

这个题目也没有想象中那么难 其实蛮简单的

主要就是我们如何将所有的情况都能够保存到最后的result中 那这就要说明我们应该将每一个迭代过程中的状态都保存到result中

所以这道题目backTracking在每一次调用之后就要立刻将当前状态下的path内部的内容作为一个结果存到result中就可以了
