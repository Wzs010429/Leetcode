# 代码随想录算法训练营第十七天｜98.验证二叉搜索树 617.合并二叉树 654.最大二叉树 700.二叉搜索树中的搜索


今天的题目都是和二叉搜索树有关的 所以我还是先把二叉搜索树的概念在这里写一下

对于一个根节点 他的左子树的所有节点都要比他小 他的所有右子树都比他要大 注意是全部节点

## 98.验证二叉搜索树

这道题目最大的坑就是 我们不能针对一个节点 只判断左子节点比他小 右子节点比他大 因为我们单单次比较只能看到临近的两个节点 但是我们需要一个全局节点来保证值的检测

### 递归


递归的处理方式就是用中序遍历：左中右

我们需要定义一个类中的变量来承载每一次处理一个子树的中间值

然后先递归左子树 然后中间 然后右边

中间的一次递归逻辑应该是 我们只需要更新这个变量为每一个子树的根节点的值即可

通过判断左子树和右子树的布尔值来判断我们的值是否满足条件


### 迭代

迭代就是一个中序遍历可以帮助我们构建出来一个有序的从小到大的数组

然后我们只要判断这个数组是不是有序的就可以了




## 617.合并二叉树


### 迭代

迭代在利用栈/队列的条件前提就是某一个节点状态是两个二叉树的这个节点都存在，我们才能对值进行加和，否则我们是没有办法对值进行加和的

如果存在了某一个树有节点但是另一个树没有节点，我们直接进行节点继承就可以了，因为只要这个位置的节点空了，那么他也不存在后续的左子节点和右子节点了



### 递归

递归法的处理和迭代法很像 中间的逻辑是 如果一个子树不存在但是另一个子树存在 那么我们直接互换继承即可

例如not root1 但是root2 我们可以直接return root2 再根据实际情况看我们是给root1修改值还是我们新建一个树来存结果 这个不影响实际结果

递归的逻辑是我们处理好当前节点之后（前提是这个节点在两个树都存在），对两个二叉树的左子树和右子树分别进行迭代


## 654.最大二叉树

递归构建二叉树

这道题目我把意思再稍微写一下：给定一个数组，我把最大的值取出来当做根节点，然后分成了左右子树，然后在分别找到左右子树的最大值，进一步进行拆分

这样我们就得到了一个二叉搜索树

所以我们的思路是 先找到最大值 那么我们就确定了root是哪一个 然后我们分别对root.left和root.right进行递归，因为我们已经拆分好了左右子树

这样我们就能通过递归把这个子树构建出来


## 700.二叉搜索树中的搜索


这道题目应该是最简单的了 递归和迭代的思路其实差不多

我们要找到一个值 如果当前节点的值比目标值大 我们就去递归或者迭代找左子树 反之我们找右子树

直到我们找到了值等于目标值的节点 直接返回该节点就可以了


