# 代码随想录算法训练营第十九天｜235.二叉搜索树的最近公共祖先 450.删除二叉搜索树中的节点 701.二叉搜索树中的插入操作



## 235.二叉搜索树的最近公共祖先


二叉搜索树的最近公共祖先相比于二叉树的最近公共祖先就要简单很多了

因为pq两个节点的值在二叉搜索树中是有规律可循的 并且他们节点一定会存在

我们还是从递归和迭代两个角度去考虑这个问题

### 递归

1. 明确终止条件

终止条件就是要么这个树是空的 要么我们遍历递归到了空节点

2. 明确递归函数的输入与输出

输入就是一个根节点root和两个要查询的节点p和q 输出应该是他们的公共祖先节点

3. 单轮递归逻辑

因为这是二叉搜索树 所以我们可以直接比较每一个节点的值来判断我们到底是应该进左子树还是右子树

如果说当前节点比pq两个节点的值都要小，我们就应该进右子树 反之（指全部大于）我们进左子树

如果说root的值跟其中一个相等或者说这个一大一小 那就说明这个是最近的公共祖先，因为我们是一点点递归进来的



### 迭代


迭代法其实和递归法的逻辑完全一样，可以通过数值的大小进行判断

都小进右子树 都大进左子树

找到的第一个不满足上面两个情况的点就是我们要找的最近公共祖先，因为我们是一点点迭代下来的




## 450.删除二叉搜索树中的节点

这道题主要是删除的节点有五种情况 在这里分别列举出来：

1. 如果删除的节点是叶子节点，那么直接删除就行了，其他的树都不需要动
2. 如果这个树没有节点（根节点就是空的），那么直接返回一个None就可以了
3. 如果这个删除的节点没有左子树，只有右子树，那么我们把右子树的第一个节点拼接到这个被删除的节点的位置就可以了
4. 如果这个删除的节点没有右子树，只有左子树，那么我们把左子树的第一个节点拼接到这个被删除的节点的位置就可以了
5. 如果这个删除的节点既有右子树也有左子树，我们需要把左子树拼接到右子树的最左下角的节点，然后把右子树的第一个节点拼接到这个被删除的节点的位置就可以了


第五点的逻辑就是：这个节点的左子树的值都比节点小，右子树最左边的一个值也要比这个原节点要大，而且是比他大的里面值最小的一个节点，所以我们要把左子树拼接在它的左边


理解了这五点条件 然后我们来考虑这个递归的三个必要元素

1. 输入输出

输入就是当前这个节点，输出应该是根据这个节点返回的子树更新结果 其实还是一个节点

2. 中止条件

当我我们遍历到空节点了就可以终止了 当然这里面其实没什么意义


3. 一轮递归的交互逻辑

就是我上面写的五点内容 所以我们的递归函数应该独立出来，在我们的主函数中我们需要处理一下一些其他的特殊情况


首先空节点肯定直接返回了 这个没得说

我们首先可以根据这个需要被删除的节点的值来找到这个节点，比大小就可以了，这个时候我们需要跟一个回溯节点，就是为了我们能找到被删除的这个节点的父节点，这里我们用cur来代表我们要深入递归的节点指针，pre代表回溯的节点

首先我们就是一个while开始往里面深入调查这个被删除节点的位置，每一次while，pre都会被更新为cur，然后cur去递归

当我们找到了等于这个值的节点，或者说我们深入递归递归到空指针了，也就是找到了叶子节点也还没有看到这个节点，这个时候我们退出这个while循环


此时 要么我们找到了这个节点，要么我们没找到 cur遍历到None了

无论怎么样，pre一定是他的上一个节点，所以我们针对pre去处理就好了：

1. 如果cur到None了，那么pre一定是一个叶子节点，我们对cur这个None节点处理肯定返回的也是None，那么就是这个二叉搜索树什么都变化
2. 如果cur找到了这个值，那么pre作为他的父节点，根据cur的情况递归调用函数查看我们应该怎么处理这个节点，就是上面的五种情况（其实不是递归，就是一个函数的调用）



## 701.二叉搜索树中的插入操作

这道题就很简单了，找到位置往里插元素就好了

而且我们**一定可以在叶子节点插入一个值**，这个很重要，一定要想明白，因为我们要插入元素，所以已经存在的二叉搜索树一定会存在空间让我们把元素插进去，即便他在某一个位置的二叉子树看起来像一个满二叉树，我们依旧是可以往叶子节点后面去插入新的值

如果能理解这个，那么迭代和递归就都好写了：

### 迭代

这个很简单 就是我们先找到这个值的位置，这个值肯定不会跟二叉搜索树中的某一个节点的值相同 所以我们放心大胆地往下传递就好了 但是别忘记了设置一个pre指针来保证我们能找到回溯的节点

一旦这个while跳出来了，就一定是我们遍历到了一个叶子节点下面的空节点，那么这个时候的pre一定是一个叶子节点，我们再去判断这个叶子节点的val和我们要插入的值哪一个大就可以了

如果taget大，我们就按照二叉搜索树的规则把他插在右子树，反之左子树




