# 代码随想录算法训练营第二十五天｜491.非递减子序列 46.全排列 47.全排列 II

今天的三个题目我觉得相对来说就比较简单了 理解好了直接按照模板就能写出来

## 491.非递减子序列

首先是 因为我们要的是全部子集 如果说这个子集满足条件了 我们就把他加到result里面去

我们引入了一个新的参数used 用来计算某一层我们是否已经使用过某一个数，这个是不考虑重复的，只要这个值被用过了就不行

在for循环内部 我们的判断方法条件有两个：

1. 新加入的这个数要比我path里面存的最大的数大或者相等
2. 因为要去重，所以在当前深度的迭代中，这个值应该是还没有被用过

然后就是如果path里面添加了一个新的值 我们得记得更改used这个数组的对应元素的状态

然后回溯的时候不仅要pop 还要把used这个元素的状态也改回来False

## 46.全排列

终止条件：path中的元素的长度和nums一样，就把这个结果输出到result里面进行添加保存

同样的 我们还是需要对每一次迭代的元素有一个单独的标记列表，来标记这个元素是否在组合中被使用过了 used

for循环外层就是对nums数组进行遍历，如果说我们在used数组中检测到了当前元素已经被使用了 那么我们直接continue跳过

然后backTracking函数传到下一层也不需要什么startIndex函数 就是还是从头开始遍历，但是这个迭代深入是带着use数组传下去的 所以这个状态会实时更新

同样的 进去的时候改了used元素状态 回溯的时候除了对path列表进行pop之外 也要把used数组的元素状态改回去丞False

## 47.全排列 II

不重复的全排列：听到不重复了，先别管，先把nums排个序sort一下

然后backTracking函数内部记得判断一下迭代的前后两个元素是否相同 这个已经写过好多遍了就没啥在需要强调的了


但是逻辑这块其实还有一点小细节需要注意一下：

```python
if (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]) or used[i]:
    continue
```

这是for循环内部的判定条件 主要是想说一下这个判断相似为什么要跟一个and not used[i - 1]

我们知道在同一轮中，如果当前这个数和上一个位置的数相同我们是不能取的，但是这两个数的关系有两种，一种是上下级（树和树枝），一种是平级（同一深度）

这里如果用 used[i - 1] == Fasle 就说明我们判断的是当前同一层中，这个数有没有被使用过

举个例子：如果我们要找112的全排列

第一轮我抽了个2，下一轮按理讲，有两个分支，我抽第一个1或者第二个1

但是这两个排列都是211的结果，我得避免去重

所以当我抽第二个1的时候，我检测到了前面的1没有被用 我才不能把这个树深入下去

还是有点抽象，再白话一点，如果前面的值跟你一样，他还没被用过，那说明什么，说明在他的轮次内部，他肯定会先抽他自己然后在下一个分支把你给抽出去，因为他在你前面，他会把他能占的坑全都占满了

所以轮到你的回合，你看到了跟你有一样的值，就应该反应过来，你能得出来的结果，人家早已经全都得出来了，就不需要你这个重复的再来一次了，所以我们会直接不进这个if判断条件 直接return


