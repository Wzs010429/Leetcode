# 代码随想录算法训练营第八天｜28.找出字符串中第一个匹配项的下标 459.重复的子字符串

今天的题目我感觉就是一整个难度的直线上升 尤其是KMP算法的理解 我觉得太需要二刷了

## 28.找出字符串中第一个匹配项的下标

首先重复一下这道题目的要求

> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。


这道题是经典的KMP算法的应用题目，虽然说这道题目被官方划分成了是easy的题目，但是我个人感觉应该是相对比较难的。

KMP的主要思想就是**在模式匹配中，如果我们已知了模式串的匹配规则，我们希望尽可能减少重复字符串的检索过程，而把整个时间复杂度缩减到O(n)**

这里面我们有两个专有名词的定义，一个是主串，另一个是模式串，我们希望在主串中找到模式串是否存在，并且返回第一次出现模式串的下标索引。

这里我们定义了一个叫做next数组的东西，这个数组是用来帮我们计算我们可以跳过多少模式串中的元素数量，从而实现了帮我们减少重复检索的情况。

具体为什么要跳过模式串中的部分元素呢？我们可以先思考一下暴力算法的实现方式：

1. 定义两个指针，分别在主串和模式串中进行遍历，都从下标0开始
2. 如果两个指针对应的值相同，就都+1，否则就主串的坐标回到下标为1的地方，模式串的下标回到0
3. 所以整体的时间复杂度应该是O(n^2)，n是主串的长度

那我们现在要做的就是主要有两点：

1. 主串我们让他不回到+1的坐标位置，如果可以的话我们希望主串的指针移动是线性的，从头到尾没有返回
2. 模式串的指针他会不可避免的回到起始位置，那么有没有可能让他不用直接回到起点


重新提到我们刚才说到的next数组，这个数组的作用就是帮我们检测我们可以跳过模式串的多少个位置的元素，而不至于直接让我们的模式串指针直接回到了下标为0的地方

这里我再举一个例子：

例如我们的主串是**ABAABABABCA** 模式串是**ABABC**

1. 刚开始两个串的坐标都在0的位置，然后开始检索，检索到第**4**个字母的时候（下标是3）主串是A但是模式串是B
2. 这时候我们通过检索next数组的信息（暂时先不考虑怎么构建的next数组），我们会保持主串的指针不动（还在下标3的位置），但是我们的模式串的指针下标不回到0了，而是从1开始
3. 解释一下：如果我们能匹配到一个开始不一样的字符，那就说明在这个字符之前，我们的主串和模式串都能够对得上
4. （接上）还是以这个例子来说话：到第一次不相同的时候，我们已经匹配上了三个字符ABA，那么他们在主串和模式串中都是完全一样的，我们这里就只看模式串中了，因为我们想要移动模式串的指针（经过next数组）
5. （接上）我们希望我们这个在模式串中的新的指针位置能够帮助我们省略掉一些已经匹配上的相同的字母，例如新的模式串指针，我们就可以从第二个字母B开始（下标1），因为前面的那个A，我们也可以在主串中匹配上
6. 通过这个思想，我们有了一个直觉，我们可以通过只找模式串中的“最长的相同前后缀”

这里有一个补充：

- 前缀的定义：从第一个字符开始但是不包含最后一个字符的所有子串的集合
- 后缀的定义：包含最后一个字符但是不包含第一个字符的所有子串的集合

7. 所以最长相同前后缀就是为了让我们找到在模式串中当前下标的值不相同的情况下，前面的所有字符里面出现的重复的串的长度是多少，这样我们可以减少我们的模式串的指针的迭代
8. 还是以上面的例子具体，我们匹配上的ABA这个子串，他的第二个A（下标2），能够和开头的A对得上，所以最长相同前后缀的长度是1
9. 再换个例子：如果是ABAB，那么最后这个B，其实可以和最开头的AB对得上，他就是两对AB，所以他的最长相同前后缀的长度是2

### Next 数组构建

所以上述就是我们Next数组需要做的事情：**找到每一个子串中的最长相等前后缀，来帮助我们减少模式串中指针的迭代次数**

接下来写一下Next数组的构建流程：

1. 首先我们还是拿一个例子来说话： **ABABC**
2. 第一个位置A肯定是0，这个没得说
3. 第二个位置B和开始的A也是不一样的，所以第二个位置（下标1）也是0
4. 第三个位置A和第一个A是一样的，能对得上，所以第三个位置（下标2）应该是1
5. 第四个位置B和第二个位置B也对得上，所以最长相同前后缀+1，第四个位置（下标3）应该是2
6. 第五个位置C和第三个A位置匹配不上了，所以变回0

这个例子还是比较简单的，但是这里面会出现一个复杂的情况，我们还是用例子说话： 新的例子是**ABACABAB**

1. 前面的ABACABA我就直接写了，他们对应的next数组的值分别是0010123
2. 我们主要聊一下最后一位B，如果我们按照原来的思路直接就变成0了 因为这个B和模式串中的最开头的A不是匹配的
3. 但是实际上我们可以看的出来，这个B可以和前一位（总长倒数第二位）的A组成AB，那么这个B的最长相等前后缀的值（next数组填充值）应该是2
4. 这个时候我们应该有一个直觉：**既然我们要找的是前面已经存在的相同前后缀，那么前面这个相同前后缀里面有没有最长的相同前后缀？**
5. 也就是说，这个模式串到倒数第二位B的时候，最长相同前后缀的长度是3，也就是ABA，那么就说明在当前这个模式串中，匹配到的ABA和这个模式串最开始的ABA是完全一致的
6. 那么我们只需要找模式串最开头的ABA中有没有相同前后缀，不就意味着我们给后面的相同前后缀找到了能匹配上的先后缀


听起来有点绕 还是举一个例子来，还是刚才的那个例子： ABACABAB

我们已经匹配到了**ABA** C **ABA** B

对于最后剩下的这个B 我们希望找到一个已经存在的开头，让他组成前后缀 那么我们就去找目前我们已经找到的最长相等前后缀的最长相等前后缀

也就是去找这个B前面，也就是ABA的最长相等前后缀 那么就是只有一个A，也恰好这个A可以和后面的AB组成一个当前最长相等前后缀，那么B对应的next数组的值应该就是2

那么怎么去找前面这个ABA的最长公共前后缀，我们应该是有一个除了模式串指针之外的额外的指针，来帮助我们记录当前找到的最长公共前后缀的长度。

例如：我们目前找到的最长公共前后缀应该是ABA，我们记flag=2（记录的是当前匹配的下标）然后flag+1等于3的时候这个C和B匹配不上了，那么我们往前-1，flag就找到了我们想要的下标值

这个时候我们查next表就可以了，因为前面的最长公共前后缀我们都已经计算出来了

综上，我们的next数组就已经构建出来了

这里放一个python代码，输入是模式串，输出是一个next数组

```python
def getNext(self, numlist):

    # 定义一个要输出的数组 这个数组的第一位肯定是0
    nextlist = [0]
    nextprefix = 0  # 当前已经有多少个相同前后缀的长度

    i = 1
    while i < len(numlist):
        if numlist[nextprefix] == numlist[i]:
            nextprefix += 1
            nextlist.append(nextprefix)
            i += 1
        else:
            if nextprefix == 0:
                nextlist.append(nextprefix)
                i += 1
            else:
                # 这块很巧妙，就是我们上面提到的flag-1 但是实际上i是不动的
                nextprefix = nextlist[nextprefix - 1]

    return nextlist
```


### 题目代码逻辑思路

如果我们构建好了next数组，那么这道题目就很简单了


就像上面我们提到的，我们希望主串中的指针是不需要每次都回到i+1的位置，模式串都回到0的位置

现在模式串的问题我们解决了，我们来看主串的指针怎么移动


这里我们还是用 主串是**ABAABABABCA** 模式串是**ABABC** 这个例子来举例

1. 最开始我们匹配上了开头的ABA，然后发现主串的A和模式串的B匹配不上了
2. 这个时候我们查表，这里注意，我们查的是没匹配上的字母的前一位字母的表，也就是我们查第三位（下标2）的A的表，查出来应该是1（这里不赘述了，就是上面的next数组构建）
3. 这个1是意味着，在模式串中，我们可以直接从下标1开始（也就是B），因为第一个A和主串中第三个位置（下标2）的A匹配上了，这就省略了我们进行匹配的次数步骤
4. 然后我们这个时候主串的下标还是没有动，在第四个位置（下标3）A，模式串的指针挪到了第二个位置（下标1）B，他俩又不一样
5. 所以我们再查表，查模式串下标-1的值（也就是下标0，第一个位置A的值）是0，这意味着接下来我们的模式串的指针挪动到开头，主串指针还不动
6. 接下来的匹配就是主串下标3的A和子串下标0的A，匹配上了，然后往后迭代。移动到第八个位置的时候，主串是A，模式串挪到了最后一位是一个C，没匹配上
7. 这个时候我们查表，next数组倒数第二位的B的下标是2，这意味着我们直接把模式串的指针挪动到下标为2的地方，主串指针下标还是7
8. 这个时候我们省略的其实是模式串中前两个字母AB，因为和主串对上了，然后在这一轮我们就可以把这个模式串匹配出来了，然后简单进行坐标计算我们就可以拿到这个模式串在主串中间出现的第一个位置


所以综上就是KMP算法的全部流程，其实还是比较有难度的 需要二刷三刷进行回顾，至少我这么写一遍之后我自己加深了理解






## 459.重复的子字符串

这道题目其实是KMP算法的高效应用

当然其实在python中现在也有find这种函数来直接帮我们找子串，但是调用函数库就让题目丧失了本身的意义

所以这道题目我们用两种解决方案，一种是调库，另一种我们还是尝试使用KMP算法来解决

首先我们来介绍一下这道题目的思想是什么：

我们想判断一个字符串s是不是由一个子串重复多次构成的，所以这个字符串A可以写成A=aaaaaa的形式

我们思考一个极端的情况 如果这个A=aa，只有两次重复

如果我们创建一个新的字符串AA=A=aaaa，那么我们检测这里面有没有A，但是我们必须从下标为1开始检索，因为如果从头开始检索必定是能检索到A的存在的

如果说在这种情况下我们检索到的A第一次出现的下标不是AA串中第二个A的起始节点，那就说明了，在我们拼接的这个字符串AA中的第一个A的后半部分，和第二个A的前半部分，应该凑成了一个新的A，那就说明了这个A字符串满足我们的条件，他是由一个更短的子串重复拼接得到的

明白了这个思路，这道题目就好解了，有两种方法：


### find法


python里面的find函数可以返回模式串在主串中第一次出现的下标，如果没找到就返回-1

所以我们只要让他查就好了，但是find函数还可以设置检索的起始下标，我们得从1开始，不能从0开头开始

并且我们希望他的检索结果应该不是第二个A的起始坐标，那么对应的下标应该就是len(A)

如果不想等那么说明这个A串就是我们想要的重复组成的串

### KMP法


KMP法更简单了，我们原始KMP算法输出的就是模式串在主串中第一次出现的下标，我们只要判断这个下标是不是len(A)就可以了

但是我们需要将拼接串AA的第一位去掉，防止他直接检索到第一个A，这道题就能解了




综上 我们需要深入了解KMP算法并且会灵活运用，这样我们就可以从容解题了