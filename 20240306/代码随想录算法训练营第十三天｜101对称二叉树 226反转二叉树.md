# 代码随想录算法训练营第十三天｜101.对称二叉树 226.反转二叉树

今天的题很少 但是胜在解法很多 主要是强化训练这些算法的运用




## 101.对称二叉树 


这个题目我们主要用来联系一下 迭代法（用栈/用队列） 递归法 和层次遍历法

先说递归法：

这两天刷题已经刷出来感觉了，迭代法使用的栈/队列是一定会把根节点放进去作为初始值，然后while对这个数据结构进行判空

递归法不需要 但是在必要的时候我们需要引入额外的指针来保证我们能够索引到上一个状态值的位置

### 递归法

首先是一些默认的异常情况，因为我们需要判断对称的情况。从根节点来考虑，我们先检查左子树和右子树的值情况

此外，对于root节点不存在的情况，我们返回的也是False而不是传统意义上的None

当我们把所有的False情况排除掉之后，就只剩下两边值都存在并且相等的情况了，这种情况我们开始递归，但是递归再往下分，左子树和右子树都分别有两个分叉

所以我们将这个树分成外侧和内侧，外侧就是左树的左侧和右树的右侧，内侧就是左树的右侧和右树的左侧

外圈单边缺失一个值，或者内圈单边缺失一个值，或者两边的值不相等 这种情况下我们返回的都是False

所以我们递归调用自身有两轮，一轮是检测内圈，一轮是检测外圈

这样在整个函数的最后如果没有任何一种情况提前返回了False 那么结果就是True

### 迭代法

迭代法用栈和用队列在这个题目里面其实没有很大的区别，主要是数据结构的不同调用方式

迭代法的主要思想就是我只要pop出来元素了 我就去进行比较 所以我们每次都pop出来两个元素并且比较他们的值

并且这两个位置的元素应该在二叉树中是对称的一个结构，例如左子树和右子树应该作为相邻的两个元素添加到栈/队列中

那么下一次就是两个内圈的数据添加进去，然后是两个外圈的数据添加进去

每一次都是两两比较，只要栈/队列中没有空，这个while就一直循环下去，所有的中间情况都会被return False 只有while循环结束了才会返回True


### 层次遍历法


这个也很有意思 因为层次遍历本质上就是一个BFS 广度优先，所以我们得一层一层来

但是如果我们不能向下进行探索，我们就需要把这个整个一层的元素个数确定好，每一层的添加都要存储到一个临时变量中，不能放在总栈/队列中

要不然我们没有一个索引指针，就直接乱了

所以这里面我们的思想是，每一层我都会统计这个节点的个数，理论上节点个数都是指数增加的 1 2 4 8 16 因为是二叉树

所以我每次往队列中存一个值 都要统计出来我的下一层的元素个数是多少 这样我的for循环就确定了存多少次

然后我们创建一个临时的数组val来存储这一层里面的每一个节点的值，如果不存在节点我们这个时候要给一个None 保证他的对称性

这样这一层循环结束之后，我们的val数组就会拿到 for循环次数长度的当前层的节点的 全部的值

判断这个数组的值的对称性 我们可以用反转相等进行判断 if val == val.reverse()




## 226.反转二叉树

这道题就是对 三种遍历方式 前序 中序 后序 的额外补充练习 并且每一种遍历方式都分别使用了 递归法和迭代法进行练习


然后同样我们也用迭代法进行了层序遍历的练习

三种递归法其实比较相似，我先将左右子树进行调换，然后我递归下去把左子树当成新的root，右子树当成新的root

内部递归调用自身两次，分别对root自身的两个子树


但是内部还是有一点点区别的：

- 前序： 前序的思路是中左右，所以我们直接先进行左右子树的调换，然后在分别递归左右子树
- 中序： 我们先进行左子树的递归，然后调换左右子树，然后再进行左子树的递归（因为换位置了）
- 后序： 先进行左子树的递归，然后进行右子树的递归，然后左右调换

所以听起来他们仨挺像的，只是为了满足不同的遍历方式而进行了一些微调

迭代法相对简单 这里面不再赘述了 就是一个栈 没空之前pop节点 然后把他的左右子树换了 然后再把左右子节点压栈

本质上这三种遍历方式的迭代法都是DFS 深度优先 其实不难理解，因为栈是后进先出，所以当我们把子节点压入栈之后，先处理的也是子节点，然后还会继续把子节点的子节点压入栈

层序遍历的迭代法 听起来还比较有意思 这个就还是BFS 所以栈不适用了，我们需要用队列 剩下的思路流程就和上面三种遍历方式一样了 队列我们用popleft

